<html>
<head>
	<style>body{font-family:Arial;} h3{font-size: 1.2em; margin-bottom: 0em;}h4{font-size: 1em; margin-bottom: 0em;}div.indented{margin-left:2em;}</style>
</head>
<body><h1>BasicClasses.poosl</h1><h2>Data classes:</h2><ul><li><a href="#data-Boolean">Boolean</a></li><li><a href="#data-Char">Char</a></li><li><a href="#data-Console">Console</a></li><li><a href="#data-FileIn">FileIn</a></li><li><a href="#data-FileOut">FileOut</a></li><li><a href="#data-Float">Float</a></li><li><a href="#data-Integer">Integer</a></li><li><a href="#data-Nil">Nil</a></li><li><a href="#data-Object">Object</a></li><li><a href="#data-Observer">Observer</a></li><li><a href="#data-RandomGenerator">RandomGenerator</a></li><li><a href="#data-Real">Real</a></li><li><a href="#data-Socket">Socket</a></li><li><a href="#data-String">String</a></li><li><a href="#data-Array">Array</a></li><li><a href="#data-Collection">Collection</a></li><li><a href="#data-Bag">Bag</a></li><li><a href="#data-Sequence">Sequence</a></li><li><a href="#data-Queue">Queue</a></li><li><a href="#data-Stack">Stack</a></li><li><a href="#data-Set">Set</a></li><li><a href="#data-Map">Map</a></li><li><a href="#data-Iterator">Iterator</a></li><li><a href="#data-MapIterator">MapIterator</a></li><li><a href="#data-BagIterator">BagIterator</a></li><li><a href="#data-SetIterator">SetIterator</a></li><li><a href="#data-SequenceIterator">SequenceIterator</a></li></ul><hr width="100%" align="left"><h1>Data classes</h1><hr width="50%" align="left"><h2><a id="data-Boolean"/>Boolean (extends Object)</h2>This primitive, permanent, native class extends Object. It represents the class of Booleans. This class has two instances represented with the constants true and false.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>!():  Boolean</h4>Using prefix notation, operator ! returns the logical inverse of the receiver. It is equivalent to b not, where b acts as the receiver.</p><p><h4>&(b:  Boolean):  Boolean</h4>Returns the logical and of the receiver and b. It has a special syntax of the form b1 & b2, where b1 acts as the receiver and b2 as the argument.</p><p><h4>|(b:  Boolean):  Boolean</h4>Returns the logical or of the receiver and b. It has a special syntax of the form b1 | b2, where b1 acts as the receiver and b2 as the argument.</p><p><h4>not():  Boolean</h4>Returns the logical inverse of the receiver. In addition to the normal syntax, it also has a special syntax of the form ! b, where b acts as the receiver.</p><p><h4>xor(b:  Boolean):  Boolean</h4>Returns the logical xor of the receiver and b. It is equivalent to (receiver!= B).</p><p><h4>asJSON():  String</h4>Returns the receiver as a valid JSON (single line) string.</p></div><hr width="50%" align="left"><h2><a id="data-Char"/>Char (extends Object)</h2>This primitive, permanent, native class extends Object. It represents the class of individual Extended ASCII characters and therefore has 256 instances representing each of the extended ASCII characters.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>asciiIndex():  Integer</h4>Returns the ASCII index number of the receiver.</p><p><h4>asString():  String</h4>Returns a new String consisting of the single receiver character.</p><p><h4>asJSON():  String</h4>Returns the receiver as a valid JSON (single line) string.</p></div><hr width="50%" align="left"><h2><a id="data-Console"/>Console (extends Object)</h2>This native class extends Object. It provides a means to write information to the console.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>write(s:  String):  Console</h4>Writes the String s as standard output to the console (not its syntactic representation). It returns the receiver.</p><p><h4>writeLine(s:  String):  Console</h4>Writes the String s as standard output to the console (its characters, not its syntactic representation) followed by new line character LF(10). It returns the receiver.</p><p><h4>writeError(s:  String):  Console</h4>Writes the String s as standard error to the console (not its syntactic representation). It returns the receiver.</p><p><h4>writeLineError(s:  String):  Console</h4>Writes the String s as standard error to the console (its characters, not its syntactic representation) followed by new line character LF(10). It returns the receiver.</p></div><hr width="50%" align="left"><h2><a id="data-FileIn"/>FileIn (extends Object)</h2>This native class extends Object. It provides a means to read information from files. Creating a new FileIn yields an object without referring to any concrete file.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>source(s:  String):  FileIn</h4>Specifies the file to read information from. s is a file name (possibly with an absolute or relative path reference - where the syntactic symbols / and \ for path references can be used interchangeably independent of OS). It returns the receiver.</p><p><h4>open():  FileIn</h4>Locks the referred file for read access. It assumes that method source has previously been called to identify the concrete file to refer to. Otherwise, an error is generated. It returns the receiver.</p><p><h4>atEndOfFile():  Boolean</h4>Returns true in case the read pointer in the file points at the end of the file and false otherwise.</p><p><h4>close():  FileIn</h4>This method and releases the referred file for further access. It returns the receiver.</p><p><h4>read(i:  Integer):  String</h4>This method reads the next first i characters from the referred file and returns that as a String if i is non-negative. If fewer than i characters are available, a String is returned consisting of the number of available characters (until the end of the file). The read pointer in the file has been advanced till after the last read character. In case i is negative an error is produced.</p><p><h4>readUntil(c:  Char):  String</h4>This method returns nil if the read pointer is at the end of the file. Otherwise, it returns the sequence of characters (as a String) until the next occurrence of character c in the file, or until the end of the file, whichever comes first. The read pointer has been advanced till after the character c if c was found or is at the end of the file if the end of the file has been encountered. The character c is not part of the returned String.</p><p><h4>readWord():  String</h4>This method returns nil if no non-white space characters exist until the end of the file. Otherwise, it returns the next consecutive sequence of non-white space characters (as a String) until the first white space character after this sequence, or until the end of the file, whichever comes first. The read pointer has been advanced till the first white space character after the sequence in the former case or is at the end of the file in the latter. None of the white space characters are part of the returned String.</p><p><h4>readLine():  String</h4>This method returns nil if the read pointer is at the end of the file. Otherwise, it returns the next (possibly empty) sequence of non-newline characters (as a String) until the first new line character sequence , or until the end of the file, whichever comes first. The read pointer has been advanced till after the longest newline character sequence after the sequence of non-newline characters (if the line ends in CR(13) followed by LF(10) it advances till after the LF(10)). None of the newline characters are part of the returned String.</p><p><h4>readString():  String</h4>This method advances until the next occurrence of a double quote character ". In case the character sequence starting from the double quote character is a valid syntactical representation of a String, then this String is returned and the read pointer in the file has advanced till after the end of the String representation. If it is not a valid syntactical representation of a String, an error is generated. If no double quote character is encountered, nil is returned.</p></div><hr width="50%" align="left"><h2><a id="data-FileOut"/>FileOut (extends Object)</h2>This native class extends Object. It provides a means to write information to files. Creating a new FileOut yields an object without referring to any concrete file.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>destination(s:  String):  FileOut</h4>Specifies the file to be referred to for writing information to. s is a file name (possibly with an absolute or relative path reference - where the syntactic symbols / and \ for path references can be used interchangeably independent of OS). In case a file with destination indicated by s already exists, that particular file is emptied. It returns the receiver.</p><p><h4>open():  FileOut</h4>(Re-)opens the referred file for write access. Performing such write accesses will result in first clearing all existing information in the file (if any). It assumes that method destination has previously been called to identify the concrete file to refer to. Otherwise, an error is generated. It returns the receiver.</p><p><h4>append():  FileOut</h4>(Re-)opens the referred file for write access. Performing such write accesses will result in appending the written information without overwriting the existing information in the file (if any). It assumes that method destination has previously been called to identify the concrete file to refer to. Otherwise, an error is generated. It returns the receiver.</p><p><h4>flush():  FileOut</h4>This method flushes all write buffers to file. It returns the receiver.</p><p><h4>close():  FileOut</h4>This method flushes all write buffers and releases the referred file for further access. It returns the receiver.</p><p><h4>write(s:  String):  FileOut</h4>Writes the String s to the referred file (not its syntactic representation). It returns the receiver.</p><p><h4>writeLine(s:  String):  FileOut</h4>Writes the String s to the file (its characters, not its syntactic representation) followed by new line character LF(10). It returns the receiver.</p><p><h4>writeString(s:  String):  FileOut</h4>Writes a syntactic representation of String s to the file. It returns the receiver.</p></div><hr width="50%" align="left"><h2><a id="data-Float"/>Float (extends Object)</h2>This primitive, permanent, native class extends Object. Its instances represents floating-point numbers using IEEE 754-2008 double-precision floating point representations. Note that the arithmetic operators operate as specified by this standard. Instances of the Float class can be distinguished from the Real class by the 'f' (or 'F') postfix, or the literals nan and inf.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>-():  Float</h4>Returns the negation of the receiver. It has a special syntax of the form -r, where r acts as the receiver.</p><p><h4>+(r:  Float):  Float</h4>Returns the sum of the receiver with r. It has a special syntax of the form r1 + r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4>/(r:  Float):  Float</h4>Returns the quotient of the receiver with r. It has a special syntax of the form r1 / r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4>*(r:  Float):  Float</h4>Returns the product of the receiver and r. It has a special syntax of the form r1 * r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4>>=(r:  Float):  Boolean</h4>Returns true in case the receiver is greater than or equal to r and false otherwise. It has a special syntax of the form r1 >= r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4>>(r:  Float):  Boolean</h4>Returns true in case the receiver is greater than r and false otherwise. It has a special syntax of the form r1 > r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4><=(r:  Float):  Boolean</h4>Returns true in case the receiver is smaller than or equal to r and false otherwise. It has a special syntax of the form r1 <= r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4><(r:  Float):  Boolean</h4>Returns true in case the receiver is smaller than r and false otherwise. It has a special syntax of the form r1 < r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4>-(r:  Float):  Float</h4>Subtracts r from the receiver and returns the result. It has a special syntax of the form r1 - r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4>abs():  Float</h4>Returns the absolute value of the receiver.</p><p><h4>acosh():  Float</h4>Returns the inverse hyperbolic sine of the receiver if the receiver is a positive value. Otherwise, an error is generated.</p><p><h4>asinh():  Float</h4>Returns the inverse hyperbolic cosine of the receiver.</p><p><h4>atanh():  Float</h4>Returns the inverse hyperbolic tangent of the receiver for values smaller or equal to (-)1. Otherwise, an error is generated.</p><p><h4>cosh():  Float</h4>Returns the hyperbolic cosine of the receiver.</p><p><h4>sinh():  Float</h4>Returns the hyperbolic sine of the receiver.</p><p><h4>tanh():  Float</h4>Returns the hyperbolic tangent of the receiver.</p><p><h4>acos():  Float</h4>Returns the arc cosine of the receiver.</p><p><h4>asin():  Float</h4>Returns the arc sine of the receiver.</p><p><h4>atan():  Float</h4>Returns the arc tangent of the receiver.</p><p><h4>atan2(p:  Float):  Float</h4>Returns the principal value of the arc tangent of the receiver / argument(p), using the signs of the receiver and argument (p) to determine the quadrant of the result.</p><p><h4>ceil():  Float</h4>Returns the smallest integral value that is not less then the receiver.</p><p><h4>cos():  Float</h4>Returns the cosine value of the receiver.</p><p><h4>exp():  Float</h4>Returns the value of e to the power of the receiver.</p><p><h4>floor():  Float</h4>Returns the largest integral value that is not greater than the receiver.</p><p><h4>log():  Float</h4>Returns the natural logarithm of the receiver.</p><p><h4>log10():  Float</h4>Returns the base 10 logarithm of the receiver.</p><p><h4>pow(p:  Float):  Float</h4>Returns the receiver raised to the power of p.</p><p><h4>round():  Float</h4>Returns the nearest integer value of the receiver, but round halfway cases away from 0.</p><p><h4>sin():  Float</h4>Returns the sine value of the receiver.</p><p><h4>sqr():  Float</h4>Returns the square of the receiver.</p><p><h4>sqrt():  Float</h4>Returns the square root of the receiver if the receiver is non-negative. Otherwise an error is generated.</p><p><h4>tan():  Float</h4>Returns the tangent of the receiver.</p><p><h4>min(p:  Float):  Float</h4>Returns the smallest value of the receiver and p.</p><p><h4>max(p:  Float):  Float</h4>Returns the biggest value of the receiver and p.</p><p><h4>monus(p:  Float):  Float</h4>Returns the difference of the receiver with p if the receiver > p or 0 otherwise.</p><p><h4>printString():  String</h4>Returns the textual representation of the value of the receiver.</p><p><h4>asInteger():  Integer</h4>Returns an Integer representation of the receiver denoting the integer number closest to the receiver. Rounding is as follows: for positive numbers: x rounds to ceil(x+1/2) for negative numbers x rounds to floor(x-1/2). It will throw an exception when the value of the receiver cannot be represented as an Integer.</p><p><h4>asFloat():  Float</h4>Returns the receiver.</p><p><h4>asReal():  Real</h4>Returns the receiver as a Real if it is a valid Real number. Otherwise an error is generated.</p><p><h4>nearbyint():  Float</h4>Returns the nearest integer value. This function returns a Float.</p><p><h4>nextafter(p:  Float):  Float</h4>Returns the next representable floating-point value following the receiver in the direction of p.</p><p><h4>remainder(p:  Float):  Float</h4>Returns the remainder of dividing x by y. The return value is x-n*y, where n is the value x / y, rounded to the nearest integer.  If the absolute value of x-n*y is 0.5, n is chosen to be even.</p><p><h4>cbrt():  Float</h4>Returns the cube root of the receiver.</p><p><h4>erf():  Float</h4>Returns the error function of the receiver (x), defined as: erf(x) = 2/sqrt(pi)* integral from 0 to x of exp(-t*t) dt.</p><p><h4>erfc():  Float</h4>Returns 1.0f - r erf().</p><p><h4>exp2():  Float</h4>Returns base-2 exponential function</p><p><h4>expm1():  Float</h4>Returns exp(x) - 1.</p><p><h4>rint():  Float</h4>Same as round, but will raise exception when inexact.</p><p><h4>trunc():  Float</h4>Returns the rounded integer value not larger in absolute value.</p><p><h4>copysign(p:  Float):  Float</h4>Returns a value whose magnitude is taken from x and whose sign is taken from y.</p><p><h4>fma(y:  Float, z:  Float):  Float</h4>Returns the result of r* y + z. The result is rounded as one ternary operation.</p><p><h4>fdim(x:  Float):  Float</h4>Returns the positive difference between the receiver and x.</p><p><h4>fmod(x:  Float):  Float</h4>Returns the value r - n*y, for some integer n, such that the returned value has the same sign as the receiver and a magnitude less than the magnitude of y.</p><p><h4>hypot(y:  Float):  Float</h4>Returns sqrt(r*r+y*y).</p><p><h4>tgamma():  Float</h4>Returns the Gamma function of the receiver. The gamma function is defined as: Gamma(x) = integral from 0 to infinity of t^(x-1) e^-t dt.</p><p><h4>lgamma():  Float</h4>Returns the natural logarithm of the absolute value of the Gamma function on the receiver.</p><p><h4>log1p():  Float</h4>Returns the logarithm of 1 plus the receiver.</p><p><h4>log2():  Float</h4>Returns the base-2 logarithmic of the receiver.</p><p><h4>logb():  Float</h4>Returns the exponent of the internal float representation of the receiver.</p><p><h4>ilogb():  Integer</h4>Returns the integer exponent of the internal floating-point representation of the receiver.</p><p><h4>isnan():  Boolean</h4>Returns true if the receiver is ''Not a Number''.</p><p><h4>isinf():  Boolean</h4>Returns true if the receiver is a positive or negative infinity.</p><p><h4>asJSON():  String</h4>Returns the receiver as a valid JSON (single line) string.</p></div><hr width="50%" align="left"><h2><a id="data-Integer"/>Integer (extends Object)</h2>This primitive, permanent, native class extends Object. It represents the class of (unbounded) integer numbers.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>-():  Integer</h4>Returns the negation of the receiver. It has a special syntax of the form -i, where i acts as the receiver.</p><p><h4>-(i:  Integer):  Integer</h4>Subtracts i from the receiver and returns the result. It has a special syntax of the form i1 - i2, where i1 acts as the receiver and i2 as the argument.</p><p><h4>*(i:  Integer):  Integer</h4>Returns the product of the receiver and i. It has a special syntax of the form i1 * i2, where i1 acts as the receiver and i2 as the argument.</p><p><h4>/(i:  Integer):  Integer</h4>This method is identical to the method div. Returns the Integer A such that A*i + B equals the receiver for some B and 0 <= B < i if i > 0 and i < B <= 0 if i < 0.</p><p><h4>&(i:  Integer):  Integer</h4>Returns an Integer representing the bit-wise and of the two's-complement of the receiver with i. It has a special syntax of the form i1 & i2, where i1 acts as the receiver and i2 as the argument.</p><p><h4>+(i:  Integer):  Integer</h4>Returns the sum of the receiver with i. It has a special syntax of the form i1 + i2, where i1 acts as the receiver and i2 as the argument.</p><p><h4><(i:  Integer):  Boolean</h4>Returns true in case the receiver is smaller than i and false otherwise. It has a special syntax of the form i1 < i2, where i1 acts as the receiver and i2 as the argument.</p><p><h4><=(i:  Integer):  Boolean</h4>Returns true in case the receiver is smaller than or equal to i and false otherwise. It has a special syntax of the form i1 <= i2, where i1 acts as the receiver and i2 as the argument.</p><p><h4>>(i:  Integer):  Boolean</h4>Returns true in case the receiver is greater than i and false otherwise. It has a special syntax of the form i1 > i2, where i1 acts as the receiver and i2 as the argument.</p><p><h4>>=(i:  Integer):  Boolean</h4>Returns true in case the receiver is greater than or equal to i and false otherwise. It has a special syntax of the form i1 >= i2, where i1 acts as the receiver and i2 as the argument.</p><p><h4>|(i:  Integer):  Integer</h4>Returns an Integer representing the bit-wise or of the two's-complement of the receiver with i. It has a special syntax of the form i1 | i2, where i1 acts as the receiver and i2 as the argument.</p><p><h4>abs():  Integer</h4>Returns the absolute value of the receiver.</p><p><h4>asAsciiChar():  Char</h4>Returns the character by using the receiver as its ASCII index number in case the receiver ranges between 0 and 255. Otherwise, an index out-of-bound error is generated.</p><p><h4>asFloat():  Float</h4>Returns a Float object with the same value as the receiver.</p><p><h4>asInteger():  Integer</h4>Returns the receiver. (Only for compatibility with Real::asInteger.)</p><p><h4>asReal():  Real</h4>Returns a Real object with the same value as the receiver.</p><p><h4>div(i:  Integer):  Integer</h4>Returns the Integer A such that A*i + B equals the receiver for some B and 0 <= B < i if i > 0 and i < B <= 0 if i < 0.</p><p><h4>fac():  Integer</h4>Returns the factorial of the receiver in case the receiver is non-negative. Otherwise, an error is generated. (Notice that 0! = 1).</p><p><h4>modulo(i:  Integer):  Integer</h4>Returns the Integer B such that A * i + B equals the receiver for some Integer A and 0 <= B < i if i > 0 and i < B <= 0 if i < 0.</p><p><h4>monus(i:  Integer):  Integer</h4>Returns the difference of the receiver with i if the receiver > i or 0 otherwise.</p><p><h4>power(i:  Integer):  Integer</h4>Returns the receiver raised to the power of i in case i is non-negative. Otherwise, an error is generated.</p><p><h4>sqr():  Integer</h4>Returns the square of the receiver.</p><p><h4>max(i:  Integer):  Integer</h4>Returns the maximum of the receiver and i.</p><p><h4>not():  Integer</h4>Returns the bit-wise negation of the receiver. It is equivalent to: -receiver - 1.</p><p><h4>min(i:  Integer):  Integer</h4>Returns the minimum of the receiver and i.</p><p><h4>xor(i:  Integer):  Integer</h4>Returns the bit-wise xor of the receiver and i.</p><p><h4>asJSON():  String</h4>Returns the receiver as a valid JSON (single line) string.</p></div><hr width="50%" align="left"><h2><a id="data-Nil"/>Nil (extends Object)</h2>This primitive, permanent, native class extends Object. It represents the class of instance nil.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>asJSON():  String</h4>Returns the receiver as a valid JSON (single line) string.</p></div><hr width="50%" align="left"><h2><a id="data-Object"/>Object</h2>This permanent, native class represents the root superclass of any other data class. It therefore provides generic methods that are applicable to all data objects.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>!=(o:  Object):  Boolean</h4>Returns true in case o is not equal to the receiver and false otherwise. The result is equivalent to (receiver = o) not. It has a special syntax of the form o1 != o2, where o1 acts as the receiver and o2 as the argument</p><p><h4>!==(o:  Object):  Boolean</h4>Returns true in case o is not identical to the receiver and false otherwise. The result is equivalent to: (receiver == o) not. It has a special syntax of the form o1 !== o2, where o1 acts as the receiver and o2 as the argument.</p><p><h4>=(o:  Object):  Boolean</h4>Implements the equality relation. For primitive objects (except for Float value nan), = is equivalent to ==. For user-defined classes, it returns true if o is an object of the same class as the receiver and all instance variables of o and the receiver are (recursively) equal as well. Otherwise, it returns false. For non-primitive native classes, the behavior is as defined for the user-defined classes, unless specified differently at the description of the class. It has a special syntax of the form o1 = o2, where o1 acts as the receiver and o2 as the argument.</p><p><h4>==(o:  Object):  Boolean</h4>Implements the identity relation. Returns true in case o refers to the same object as the receiver. Otherwise, it returns false. It has a special syntax of the form o1 == o2, where o1 acts as the receiver and o2 as the argument.</p><p><h4>deepCopy():  Object</h4>For user-defined classes not extending non-permanent native classes, it returns a clone of the receiver as a new object. This means that a new instance of the receiver's class is returned, where each instance variable is assigned to clones in a recursive manner, such that all (indirect) references to the same original object result in references to a single cloned object. The original and cloned data object structures are isomorphic. For primitive classes, the receiver itself is returned. The non-permanent native classes (and any user-defined subclasses) do not support copying and therefore, an error is generated. For non-primitive permanent classes, the behavior is as defined for the user-defined classes, unless specified differently at the description of the class.</p><p><h4>error(s:  String):  Object</h4>This method allows to signal erroneous behavior. Semantically it does nothing, but tools tend to halt execution of a model after this method and show message s to the user.</p><p><h4>assert(b:  Boolean, s:  String):  Object</h4>This method allows to signal erroneous behavior for a condition b. Semantically it does nothing, but tools tend to halt execution of a model after this method when expression b evaluates to false and show message s to the user.</p><p><h4>marshal():  String</h4>Returns a standardized String representation of the receiver. The inverse functionality is implemented as method unmarshal in class String. It can for example be used to communicate arbitrary objects between different POOSL models via files or sockets in a standardized way.</p><p><h4>printString():  String</h4>Returns a String representation of the receiver. It is the typical means used by tools to retrieve a representation of an object to users of those tools. The standard behavior in class Object returns just the class name. This is overridden in subclasses to display more specific information on the object. If the receiver is an instance of a primitive class or class String, the syntactic constant representation of the receiver is returned.</p><p><h4>shallowCopy():  Object</h4>For user-defined classes not extending non-permanent native classes, it returns a shallow copy of the receiver. This means that a new object of the receiver's class is created, for which the instance variables refer to the same objects as the corresponding instance variables of the receiver. For primitive classes, the receiver itself is returned. For non-permanent native classes (and any user-defined subclasses), an error is generated. For non-primitive permanent classes, the behavior is as defined for the user-defined classes, unless specified differently at the description of the class.</p><p><h4>isOfType(s:  String):  Boolean</h4>If s does not refer to the name of an existing data class, an error is generated. In case s does refer to the name of an existing data class, true is returned in case the receiver is of the type associated with the data class with name s and false otherwise.</p></div><hr width="50%" align="left"><h2><a id="data-Observer"/>Observer (extends Object)</h2>This native class extends Object. It can be used to monitor the simulated system and it provides a means for POOSL tools to terminate an execution or interact with other tools based on observation results. Creating a new Observer yields an unregistered observer object. While unregistered it has no effect on execution of a model. Registering an Observer makes it relevant in the condition to terminate the execution. In case method complete has been called for all Observer instances in a POOSL model since their registration (and there is at least one registered Observer), the execution terminates. Execution also terminates when method halt is called for any registered Observer.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>identifyWith(s:  String):  Observer</h4>Sets the Observer's human-readable identity to s.</p><p><h4>identity():  String</h4>Returns the Observer's identity.</p><p><h4>result():  String</h4>This method returns a String representation of the results for the monitored property. Tools typically use it to communicate observer state to external tools. By default, the result of method printString is returned. Method result can be overridden in subclasses to return specific information on the monitored properties.</p><p><h4>register():  Observer</h4>Marks the Observer to be relevant for terminating the simulation. If the Observer executed the complete method before, it is only considered activated until it executes the complete method again.</p><p><h4>deregister():  Observer</h4>Marks the Observer to be irrelevant for terminating the simulation.</p><p><h4>complete():  Observer</h4>Marks the Observer as activated to terminate the simulation. The simulation actually terminates at the moment that all observers were activated by calling method complete since their registration.</p><p><h4>halt():  Observer</h4>The simulation terminates immediately when any registered Observer executes this method.</p><p><h4>isLast():  Boolean</h4>Returns true when the receiver is the last Observer not yet activated.</p></div><hr width="50%" align="left"><h2><a id="data-RandomGenerator"/>RandomGenerator (extends Object)</h2>This native class extends Object. It represents a generator of pseudo-random values with a uniform distribution U[0,1).<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>random():  Real</h4>Returns a Real sample from distribution U[0, 1).</p><p><h4>randomInt(i:  Integer):  Integer</h4>Returns an Integer sample from discrete uniform distribution [0, i-1] for i > 0. In case i <= 0, an error is generated.</p><p><h4>randomiseSeed():  RandomGenerator</h4>This method arbitrarily modifies the seed for the sequence of pseudo-random numbers successively produced by calling methods random and randomInt. The exact behavior is implementation dependent, typically setting the seed to a time-dependent value. Note that when the randomiseSeed or seed methods are not used, every instance of this class will produce the same sequence of pseudo random numbers. Using randomiseSeed disables exact reproductions of executions. It returns the receiver.</p><p><h4>seed(i:  Integer):  RandomGenerator</h4>Sets the seed of the receiver to i. It returns the receiver.</p></div><hr width="50%" align="left"><h2><a id="data-Real"/>Real (extends Object)</h2>This primitive, permanent, native class extends Object. Custom floating point implementation; see data class Float for the IEEE 754-2008 standard.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>-():  Real</h4>Returns the negation of the receiver. It has a special syntax of the form -r, where r acts as the receiver.</p><p><h4>-(r:  Real):  Real</h4>Subtracts r from the receiver and returns the result. It has a special syntax of the form r1 - r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4>*(r:  Real):  Real</h4>Returns the product of the receiver and r. It has a special syntax of the form r1 * r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4>/(r:  Real):  Real</h4>Returns the quotient of the receiver with r. It has a special syntax of the form r1 / r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4>+(r:  Real):  Real</h4>Returns the sum of the receiver with r. It has a special syntax of the form r1 + r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4><(r:  Real):  Boolean</h4>Returns true in case the receiver is smaller than r and false otherwise. It has a special syntax of the form r1 < r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4><=(r:  Real):  Boolean</h4>Returns true in case the receiver is smaller than or equal to r and false otherwise. It has a special syntax of the form r1 <= r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4>>(r:  Real):  Boolean</h4>Returns true in case the receiver is greater than r and false otherwise. It has a special syntax of the form r1 > r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4>>=(r:  Real):  Boolean</h4>Returns true in case the receiver is greater than or equal to r and false otherwise. It has a special syntax of the form r1 >= r2, where r1 acts as the receiver and r2 as the argument.</p><p><h4>abs():  Real</h4>Returns the absolute value of the receiver.</p><p><h4>acos():  Real</h4>Returns the arccosine of the receiver if the receiver is in [-1.0, 1.0]. Otherwise, an error is generated.</p><p><h4>asin():  Real</h4>Returns the arcsine of the receiver if the receiver is in [-1.0, 1.0]. Otherwise, an error is generated.</p><p><h4>asFloat():  Float</h4>Returns a Float object with the same value as the receiver.</p><p><h4>asInteger():  Integer</h4>Returns an Integer representation of the receiver denoting the integer number closest to the receiver. Rounding is as follows: for positive numbers: x rounds to floor(x + 1/2) for negative numbers x rounds to ceiling(x - 1/2).</p><p><h4>asReal():  Real</h4>Returns the receiver. (Only for compatibility with Integer::asReal.)</p><p><h4>atan():  Real</h4>Returns the arctangent of the receiver.</p><p><h4>atan2(r:  Real):  Real</h4>Returns the angle in radians between the vector (receiver, r) and the vector (1, 0).</p><p><h4>ceiling():  Real</h4>Returns the smallest rounded Real that is not smaller than the receiver.</p><p><h4>cos():  Real</h4>Returns the cosine of the receiver (as an angle in radians).</p><p><h4>exp():  Real</h4>Returns e (the base of the natural logarithm) to the power of the receiver.</p><p><h4>floor():  Real</h4>Returns the largest rounded Real that is not larger than the receiver.</p><p><h4>ln():  Real</h4>Returns the natural logarithm of the receiver if the receiver is positive. Otherwise, an error is generated.</p><p><h4>log():  Real</h4>Returns the 10-based logarithm of the receiver if the receiver is positive. Otherwise, an error is generated.</p><p><h4>monus(r:  Real):  Real</h4>Returns the difference of the receiver with r if the receiver > r or 0 otherwise.</p><p><h4>power(r:  Real):  Real</h4>Returns the receiver raised to the power of r.</p><p><h4>round():  Real</h4>Returns the rounded Real closest to the receiver (as an Integer). Rounding is as follows: for positive numbers: x rounds to floor(x + 1/2) for negative numbers x rounds to ceiling(x - 1/2).</p><p><h4>sin():  Real</h4>Returns the sine of the receiver (as an angle in radians).</p><p><h4>sqr():  Real</h4>Returns the square of the receiver.</p><p><h4>sqrt():  Real</h4>Returns the square root of the receiver in case the receiver is non-negative. Otherwise, an error is generated.</p><p><h4>tan():  Real</h4>Returns the tangent of the receiver (as an angle in radians).</p><p><h4>max(r:  Real):  Real</h4>Returns the maximum of the receiver and r.</p><p><h4>min(r:  Real):  Real</h4>Returns the minimum of the receiver and r.</p><p><h4>asJSON():  String</h4>Returns the receiver as a valid JSON (single line) string.</p></div><hr width="50%" align="left"><h2><a id="data-Socket"/>Socket (extends Object)</h2>This native class extends Object. It provides a means to communicate via TCP/IP through sockets. Creating a new Socket yields an unconnected TCP/IP socket. For simplicity reasons, a Socket supports at most one connection between a server and client.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>acceptFrom(i:  Integer):  Socket</h4>Passively accepts a TCP/IP connection from local port i. It returns the receiver.</p><p><h4>connectTo(s:  String, i:  Integer):  Socket</h4>Actively establishes a TCP/IP connection to a remote socket with remote server named s or with IP address s and remote port number i. It returns the receiver.</p><p><h4>isConnected():  Boolean</h4>Returns true in case is the receiver is connected and false otherwise.</p><p><h4>isDisconnected():  Boolean</h4>Returns true in case is the receiver is disconnected and false otherwise.</p><p><h4>close():  Socket</h4>Releases the concrete socket (if it was created) for further communication. It returns the receiver.</p><p><h4>hasCharacters(i:  Integer):  Boolean</h4>Returns true in case there are at least i characters available for reading and false otherwise.</p><p><h4>readCharacters(i:  Integer):  Array</h4>This method returns nil in case less than i characters are available for reading (without advancing the read pointer). Otherwise, it returns the sequence of first i characters (as an Array containing Char elements). The read pointer has been advanced till after the last read character.</p><p><h4>read(i:  Integer):  String</h4>This method reads the next sequence of i available characters and returns them as a String if i is non-negative. If fewer than i characters are available, a String is returned consisting of the number of available characters. The read pointer has been advanced till after the last read character. In case i is negative, an error is produced.</p><p><h4>hasCharacter(c:  Char):  Boolean</h4>Returns true in case there is at least one occurrence of character c available for reading and false otherwise.</p><p><h4>readUntil(c:  Char):  String</h4>This method returns nil in case no character 'c' is available (without advancing the read pointer). Otherwise, it returns the sequence of characters (as a String) until the first occurrence of character 'c'. The read pointer has been advanced till after the last read character. The character 'c' is not returned as part of the String.</p><p><h4>hasWord():  Boolean</h4>Returns true in case a non-empty sequence of non-white space characters is available for reading, preceded by a possibly empty sequence of white-space characters and succeeded by at least one white space character. Otherwise, it returns false.</p><p><h4>readWord():  String</h4>This method returns nil in case no sequence of non-white space characters is available that is succeeded by a white space character (without advancing the read pointer). Otherwise, it returns the sequence of non-white space characters (as a String) after a possibly empty sequence of white-space characters, until the first white space character after this sequence. The read pointer has been advanced till immediately after the first white space character after the sequence of non-white space characters. None of the white space characters before or after the word are part of the returned String.</p><p><h4>hasLine():  Boolean</h4>Returns true in case a newline character sequence is available (possibly after other characters) and false otherwise.</p><p><h4>readLine():  String</h4>This method returns nil in case no new line character sequence is available (without advancing the read pointer). Otherwise it returns the sequence of non-new line characters (as a String) until the first new-line character sequence after this sequence. The read pointer has been advanced till after the longest new-line character sequence immediately following the non-newline characters (if the line ends in CR(13) followed by LF(10) it advances till after the LF(10)). The new line characters are not part of the returned String.</p><p><h4>hasString():  Boolean</h4>Returns true in case in the sequence available for reading the first occurrence of a double quote forms with a sequence of following characters either a (complete) syntactic representation of a String, or is an invalid beginning of a syntactic representation of a String, i.e., cannot be completed to a valid String constant. It returns false otherwise.</p><p><h4>readString():  String</h4>This method advances until the next occurrence of a double quote character ". In case the character sequence starting from the double quote character is a valid syntactical representation of a String, then this String is returned. The read pointer has advanced till after the end of the String representation. In case the character sequence is not a valid syntactical representation of a String and cannot be completed to a valid String, an error is generated. In all other cases, nil is returned (without advancing the read pointer).</p><p><h4>write(s:  String):  Socket</h4>Writes the String s to the referred socket (not its syntactic representation). It returns the receiver.</p><p><h4>writeCharacters(a:  Array):  Socket</h4>Writes the characters in the array to the socket. The array parameter is only allowed to contain characters. It returns the receiver.</p><p><h4>writeLine(s:  String):  Socket</h4>Writes the String s to the referred file (not its syntactic representation) followed by new line character LF(10). It returns the receiver.</p><p><h4>writeString(s:  String):  Socket</h4>Writes the syntactic representation of s to the socket. It returns the receiver.</p></div><hr width="50%" align="left"><h2><a id="data-String"/>String (extends Object)</h2>This permanent, native class extends Object. It represents the class of strings (of arbitrary size).<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>=(o:  Object):  Boolean</h4>Returns true in case o refers to a String identical to the receiver. Otherwise, it returns false. It has a special syntax of the form o1 = o2, where o1 acts as the receiver and o2 as the argument.</p><p><h4>+(s:  String):  String</h4>Returns the concatenation of the receiver and s (as a new String). It has a special syntax of the form s1 + s2, where s1 acts as the receiver and s2 as the argument.</p><p><h4>deepCopy():  Object</h4>Returns a new String, identical to the receiver.</p><p><h4>shallowCopy():  Object</h4>Returns a new String, identical to the receiver.</p><p><h4>concat(s:  String):  String</h4>Modifies the receiver by concatenation with s. It returns the receiver.</p><p><h4>cr():  String</h4>Modifies the receiver by concatenation with a carriage return character CR(13). It returns the receiver.</p><p><h4>lf():  String</h4>Modifies the receiver by concatenation with a line feed character LF(10). It returns the receiver.</p><p><h4>tab():  String</h4>Modifies the receiver by concatenation with a tab character HT(9). It returns the receiver.</p><p><h4>find(i:  Integer, s:  String):  Integer</h4>This method searches the receiver for a substring s, starting from index i. If pattern s is found, the index (between 1 and the size of the receiver) at which s starts is returned. In case i is smaller than 1 or larger than the size of the receiver, an index out-of-bounds error is generated. In all other cases, it returns 0.</p><p><h4>at(i:  Integer):  Char</h4>Returns the character at index i in case i ranges between 1 and the size of the receiver. Otherwise, an index out-of-bounds error is generated.</p><p><h4>size():  Integer</h4>Returns the number of characters constituting the receiver.</p><p><h4>putAt(i:  Integer, c:  Char):  String</h4>Modifies the receiver by replacing the character at index i with c in case i ranges between 1 and the size of the receiver. Otherwise, an index out-of-bounds error is generated. It returns the receiver.</p><p><h4>subString(i:  Integer, l:  Integer):  String</h4>Returns a new String containing a copy of the substring with size l, starting at index i in case i is between 1 and the size of the receiver, l is non-negative  and i + l-1 is at most equal to the size of the receiver. Otherwise, an index out-of-bounds error is generated.</p><p><h4>unmarshal():  Object</h4>This method reconstructs an Object from a standardized String representation as created by the method marshal of class Object. If the receiver does not conform to the marshal syntax, an error occurs.</p><p><h4>splitOn(c:  Char):  Array</h4>Returns an Array of String objects, constructed by splitting the receiver into substrings at characters c. The new String objects in the returned Array do not contain character c. Notice that in case the receiver contains a sequence of characters c, the returned Array will contain empty Strings. In case c is not included in the receiver, the returned Array solely contains a copy of the receiver.</p><p><h4>splitOnWhiteSpace():  Array</h4>Returns an Array of String objects, constructed by splitting the receiver into substrings delimited by one or more white space characters. The new String objects in the returned Array do not contain any white space characters. White space characters at the beginning and end of the receiver are ignored and if the receiver consists of white space characters only, an empty Array is returned. In case the receiver does not contain any white-space characters, the returned Array solely contains a copy of the receiver.</p><p><h4>splitOnString(s:  String):  Array</h4>Returns an Array of String objects, constructed by splitting the receiver into substrings at string s. The new String objects in the returned Array do not contain string s. Notice that in case the receiver contains a sequence of string s, the returned Array will contain empty Strings. In case s is not included in the receiver, the returned Array solely contains a copy of the receiver. Splitting the string is done from left to right. Splitting the string "aapppoa" on "pp" therefor results in: "aa", "poa".</p><p><h4>splitOnAny(c:  String):  Array</h4>Returns an Array of String objects, constructed by splitting the receiver into substrings at any of characters in s. The new String objects in the returned Array do not contain any of the characters in s. Notice that in case the receiver contains a sequence of characters in s, the returned Array will contain empty Strings. In case any of the characters of s is not included in the receiver, the returned Array solely contains a copy of the receiver.</p><p><h4>trim():  String</h4>Returns a new string where the leading and trailing whitespaces are removed.</p><p><h4>isBoolean():  Boolean</h4>Returns true in case the receiver is the String representation of a Boolean object and false otherwise. No extra white space or other characters are allowed.</p><p><h4>isChar():  Boolean</h4>Returns true in case the receiver is the String representation of a Char object and false otherwise. The character must include surrounding single quotes and may use escape characters. No extra white space or other characters are allowed.</p><p><h4>isNumber():  Boolean</h4>Returns "receiver isFloat | receiver isInteger | receiver isReal".</p><p><h4>isFloat():  Boolean</h4>Returns true in case the receiver is the String representation of a Float object and false otherwise. No extra white space or other characters are allowed.</p><p><h4>isInteger():  Boolean</h4>Returns true in case the receiver is the String representation of an Integer object and false otherwise. No extra white space or other characters are allowed.</p><p><h4>isReal():  Boolean</h4>Returns true in case the receiver is the String representation of a Real object and false otherwise. No extra white space or other characters are allowed.</p><p><h4>parseAsFloat():  Float</h4>If "receiver isFloat", it returns "receiver toFloat". If "receiver isReal", it returns "receiver toReal asFloat". If "receiver isInteger", it returns "receiver toInteger asFloat". Otherwise, it returns nil.</p><p><h4>parseAsInteger():  Integer</h4>If "receiver isInteger", it returns "receiver toInteger". If "receiver isReal", it returns "receiver toReal asInteger". Otherwise, it returns nil.</p><p><h4>parseAsReal():  Real</h4>If "receiver isReal", it returns "receiver toReal". If "receiver isInteger", it returns "receiver toInteger asReal". Otherwise, it returns nil.</p><p><h4>toBoolean():  Boolean</h4>If the receiver is the String representation of a Boolean object (in line with the isBoolean method), this object is returned. Otherwise, nil is returned.</p><p><h4>toChar():  Char</h4>If the receiver is the String representation of a Char object (in line with the isChar method), this object is returned. Otherwise, nil is returned.</p><p><h4>toFloat():  Float</h4>If the receiver is the String representation of a Float object (in line with the isFloat method), this object is returned. Otherwise, nil is returned.</p><p><h4>toInteger():  Integer</h4>If the receiver is the String representation of an Integer object (in line with the isInteger method), this object is returned. Otherwise, nil is returned.</p><p><h4>toReal():  Real</h4>If the receiver is the String representation of a Real object (in line with the isReal method), this object is returned. Otherwise, nil is returned.</p><p><h4>parseJSON():  Object</h4>If the receiver denotes a valid JSON string, a POOSL object for the JSON string is returned. Otherwise, nil is returned.</p><p><h4>asJSON():  String</h4>Returns the receiver as a valid JSON (single line) string.</p></div><hr width="50%" align="left"><h2><a id="data-Array"/>Array (extends Object)</h2>This permanent, native class extends Object. It represents an indexed list of (arbitrary typed) objects. Creating a new Array yields an indexed list of size 0 (empty Array). Valid indices for non-empty Arrays range from 1 to the size of the Array.<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>=(o:  Object):  Boolean</h4>Returns true in case o is an Array of the same size as the receiver and for each index, the objects both Arrays refer to are equal (in terms of =). Otherwise, it returns false.</p><p><h4>+(a:  Array):  Array</h4>Returns a new Array consisting of a copy of the receiver that has the size of the receiver plus the size of a, where the indices between 1 and the size of the receiver are filled with the objects in the receiver (in the same order) and the indices between the size of the receiver + 1 and the size of the returned Array contain the objects in a (in the same order). It has a special syntax of the form a1 + a2, where a1 acts as the receiver and a2 as the argument.</p><p><h4>deepCopy():  Object</h4>Returns a new Array object with the same size as the receiver and at each index, a recursive deepCopy of the object referred to by the receiver at that index.</p><p><h4>shallowCopy():  Object</h4>Returns a new Array object with the same size as the receiver and at each index, it refers to the same object referred to by the receiver at that index.</p><p><h4>printString():  String</h4>Returns a String equal to "Empty Array" in case the receiver has size 0. Otherwise, it consists of String "Array(" followed by a comma separated list of Strings, the result s of calling printString on the objects from index 1 to the size of the receiver, followed by ")".</p><p><h4>at(i:  Integer):  Object</h4>Returns the object located at index i in case i ranges between 1 and the size the receiver. Otherwise, an index out-of-bounds error is generated.</p><p><h4>size():  Integer</h4>Returns the size of the receiver.</p><p><h4>putAt(i:  Integer, o:  Object):  Array</h4>Replaces the object at index i with o in case i ranges between 1 and the size of the receiver. Otherwise, an index out-of-bounds error is generated. It returns the receiver.</p><p><h4>putAll(o:  Object):  Array</h4>Makes all indices in the receiver refer to object o (without making copies). It returns the receiver.</p><p><h4>resize(i:  Integer):  Array</h4>Modifies the size of the receiver to i (in case i >= 0). In case i < 0, an error is generated. When i is larger than the original size of the receiver, all new locations are filled with nil. When i is smaller than the original size of the receiver, the objects at indices between i+1 and the original size will no longer be contained. It returns the receiver.</p><p><h4>concat(a:  Array):  Array</h4>Modifies the receiver by increasing its size with the size of a, where the indices between the size of the receiver + 1 and the size of the returned Array contain the objects in a (in the same order).</p><p><h4>find(i:  Integer, o:  Object):  Integer</h4>This method searches the receiver for object o, starting from index i. If an object equal to o is found, the index (between 1 and the size of the receiver) at which o is located is returned. In case i is smaller than 1 or larger than the size of the receiver, an index out-of-bounds error is generated. In all other cases, it returns 0.</p><p><h4>subArray(i:  Integer, l:  Integer):  Array</h4>Returns a new Array of size l containing a copy of the objects in the receiver starting at index i in case i is between 1 and the size of the receiver, l is non-negative and i + l-1 is at most equal to the size of the receiver. Otherwise, an index out-of-bounds error is generated.</p><p><h4>asJSON():  String</h4>Returns the receiver as a valid JSON (single line) string. It will throw an exception when it contains a non-serializable object.</p></div><hr width="50%" align="left"><h2><a id="data-Collection"/>Collection (extends Object)</h2>Collection - Super class for Bag, Set, Map, Stack, Queue and Sequence<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>clear():  Collection</h4>Clears the contents of the Collection (by removing all elements)</p><p><h4>isEmpty():  Boolean</h4>Returns true in case the Collection does not contain any elements. Otherwise, it returns false</p><p><h4>size():  Integer</h4>Returns the number of elements in the Collection</p><p><h4>excludes(O:  Object):  Boolean</h4>Returns true in case O is not contained in the Collection. Otherwise, it returns false</p><p><h4>excludesAll(C:  Collection):  Boolean</h4>Returns true in case (no instance of) each element in C is not contained in the Collection. Otherwise, it  returns false. In case C is not a Collection, an error is generated</p><p><h4>includes(O:  Object):  Boolean</h4>Returns true in case O is contained in the Collection. Otherwise, it returns false</p><p><h4>includessAll(C:  Collection):  Boolean</h4>Returns true in case ( all instances of) each element in C is contained in the Collection. Otherwise, it  returns false. In case C is not a Collection, an error is generated</p><p><h4>toArray():  Array</h4>Returns an Array that contains the elements in the Collection (with duplicate instances). In case the Collection is a Sequence, the ordering of the elements (and indices of the elements) is preserved</p><p><h4>toBag():  Bag</h4>Returns a Bag that contains all elements in the Collection (with duplicate instances)</p><p><h4>toSequence():  Sequence</h4>Returns a Sequence that contains all elements in the Collection (with duplicate instances). In case the collection is a Sequence, the ordering of the elements (and indices of the elements) is preserved</p><p><h4>count(O:  Object):  Integer</h4>Returns the number of duplicate instances of O in the Bag</p></div><hr width="50%" align="left"><h2><a id="data-Bag"/>Bag (extends Collection)</h2>Bag (Unordered Multi-Set) - Creating a Bag yields an empty Unordered Collection (Possibly With Duplicate Instances)<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>=(B:  Object):  Boolean</h4>Returns true in case B is a Bag and the Bag and B contain the same objects in equal numbers. Otherwise, false is returned</p><p><h4>!=(B:  Object):  Boolean</h4>Returns !(self = B)</p><p><h4>+(B:  Bag):  Bag</h4>Returns a new Bag that contains those elements included in both the receiver and B. The number of duplicate instances becomes the sum of the number of the duplicate instances in the receiver and B. In case B is not a Bag, an error is generated</p><p><h4>-(B:  Bag):  Bag</h4>Returns a new Bag that only contains those elements of the receiver that are not included in B. The number of duplicate instances becomes the number of the duplicate instances in the receiver minus the number of duplicate instances in B (if larger than 0, otherwise they are all removed). In case B is not a Bag, an error is generated</p><p><h4>>(B:  Bag):  Boolean</h4>Returns true in case the Bag is a strict super bag of B, where the number of duplicate instances (for each least one element) in the Bag must be strictly larger than the number of duplicate instances in B. Otherwise, false is returned. In case B is not a Bag, an error is generated</p><p><h4>>=(B:  Bag):  Boolean</h4>Returns true in case the Bag is a super bag of B, where the number of duplicate instances in the Bag must be larger than or equal to the number of duplicate instances in B. Otherwise, false is returned. In case B is not a Bag, an error is generated</p><p><h4><(B:  Bag):  Boolean</h4>Returns true in case the Bag is a strict sub bag of B, where the number of duplicate instances (for each least one element) in the Bag must be strictly smaller than the number of duplicate instances in B. Otherwise, false is returned. In case B is not a Bag, an error is generated</p><p><h4><=(B:  Bag):  Boolean</h4>Returns true in case the Bag is a sub bag of B, where the number of duplicate instances in the Bag must be smaller than or equal to the number of duplicate instances in B. Otherwise, false is returned. In case B is not a Bag, an error is generated</p><p><h4>iterator():  BagIterator</h4>Returns an iterator for traversing the Bag</p><p><h4>fromArray(A:  Array):  Bag</h4>Modifies the Bag by clearing its contents and subsequently adding all elements of Array A</p><p><h4>isUnique():  Boolean</h4>Returns true in case the Bag does not contain duplicate instances. Otherwise, false is returned</p><p><h4>count(O:  Object):  Integer</h4>Returns the number of duplicate instances of O in the Bag</p><p><h4>add(O:  Object):  Bag</h4>Modifies and returns the Bag after adding object O</p><p><h4>addMultiple(O:  Object, N:  Integer):  Bag</h4>Modifies and returns the Bag after adding N duplicate instances of O if N is a non-negative integer. Otherwise, an error is generated</p><p><h4>remove(O:  Object):  Bag</h4>Removes one instance of O from the Bag (if such instance is included). It returns the Bag</p><p><h4>removeMultiple(O:  Object, N:  Integer):  Bag</h4>Removes N instances of O from the Bag (if such instances are included) if N is a non-negative Integer. If N is larger than the number of duplicate instances of O in the Bag, all duplicate instances of O are removed. It returns the Bag</p><p><h4>removeDuplicates():  Bag</h4>Returns the Bag after removing all duplicate instances of elements (if any)</p><p><h4>union(B:  Bag):  Bag</h4>Modifies the Bag by adding all elements from B. The number of duplicate instances becomes the sum of the number of the duplicate instances in the Bag and B. In case B is not a Bag, an error is generated</p><p><h4>subtract(B:  Bag):  Bag</h4>Modifies the Bag by removing all elements from B. The number of duplicate instances becomes the number of the duplicate instances in the Bag minus the number of duplicate instances in B (if larger than 0, otherwise they are all removed). In case B is not a Bag, an error is generated</p><p><h4>difference(B:  Bag):  Bag</h4>Modifies the Bag to become the symmetric difference of the Bag and B. This means that those elements of the Bag that are in B are removed (such that a minimum number of duplicate instances remains, if positive) and those elements in B that are not in the Bag are added (including duplicate instances). In case B is not a Bag, an error is generated</p><p><h4>intersection(B:  Bag):  Bag</h4>Modifies the Bag to contain only those elements that are contained in both the Bag and B. The number of duplicate instances becomes the minimum of the number of the duplicate instances included in the Bag and B. In case B is not a Bag, an error is generated</p><p><h4>printString():  String</h4>Returns a pretty print</p></div><hr width="50%" align="left"><h2><a id="data-Sequence"/>Sequence (extends Collection)</h2>Sequence (Bi-Directional List) - Creating a Sequence yields an empty Ordered Collection (Possibly With Duplicate Instances). Valid indices for non-empty Sequences range from 1 to the size of the Sequence<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>+(S:  Sequence):  Sequence</h4>Returns a new Sequence containing all elements in the receiver succeeded by all elements of S. In case S is not a Sequence, an error is generated</p><p><h4>iterator():  SequenceIterator</h4>Returns a (forward directed) iterator for traversing the Sequence</p><p><h4>fromArray(A:  Array):  Sequence</h4>Modifies the Sequence by clearing its contents and subsequently appending all elements of Array A (with duplicate instances and preserving the ordering)</p><p><h4>isUnique():  Boolean</h4>Returns true in case the Sequence does not contain any duplicate instances. Otherwise, false is returned</p><p><h4>count(O:  Object):  Integer</h4>Returns the number of duplicate instances of O in the Sequence</p><p><h4>append(O:  Object):  Sequence</h4>Adds O to the Sequence after the last position</p><p><h4>prepend(O:  Object):  Sequence</h4>Adds O to the Sequence before the first position</p><p><h4>putAt(I:  Integer, O:  Object):  Sequence</h4>Modifies the Sequence by replacing the element at index I with O. In case I is not an Integer or if it is smaller than 1 or greater than the size of the Sequence, an error is generated</p><p><h4>insertAt(I:  Integer, O:  Object):  Sequence</h4>Modifies the Sequence by inserting element O at index I. In case I is not an Integer or if it is smaller than 1 or greater than the size of the Sequence, an error is generated</p><p><h4>at(I:  Integer):  Object</h4>Returns the element at index I. In case I is not an Integer or if it is smaller than 1 or greater than the size of the Sequence, an error is generated</p><p><h4>first():  Object</h4>Returns the first element in the Sequence (or nil if it is empty)</p><p><h4>last():  Object</h4>Returns the last element in the Sequence (or nil if it is empty)</p><p><h4>removeAt(I:  Integer):  Sequence</h4>Modifies the Sequence by removing the element at index I. In case I is not an Integer or if it is smaller than 1 or greater than the size of the Sequence, an error is generated</p><p><h4>removeFirst():  Sequence</h4>Returns the Sequence after removing the first element (if not empty)</p><p><h4>removeLast():  Sequence</h4>Returns the Sequence after removing the last element (if not empty)</p><p><h4>concat(S:  Sequence):  Sequence</h4>Modifies the Sequence by appending all elements of S. In case S is not a Sequence, an error is generated</p><p><h4>reverse():  Sequence</h4>Modifies the Sequence by reversing the order of the elements</p><p><h4>splice(I:  Integer, S:  Sequence):  Sequence</h4>Modifies the Sequence by inserting all elements of S from index I onwards. In case the Sequence is not empty, an error is generated if S is not a Sequence, if I is not an Integer or if it is smaller than 1 or greater than the size of the Sequence</p><p><h4>swap(I:  Integer, J:  Integer):  Sequence</h4>Modifies the Sequence by swapping the elements at index I and J. In case the Sequence is not empty and I differs from J then an error is generated if either I or J is not an Integer or if I and J are smaller than 1 or greater than the size of the Sequence</p><p><h4>subSequence(I:  Integer, L:  Integer):  Sequence</h4>Returns a new Sequence that will contain the elements of the receiver from and including index I until and including index I + L. In case the receiver is not empty, an error is generated in case I and L are not Integers, if L is negative or if I and I + L + 1 range outside the index range of the Sequence</p><p><h4>find(I:  Integer, O:  Object):  Integer</h4>This method searches the Sequence for the first instance of O, starting from index I. If an instance of O is found, the index (between 1 and the size of the Sequence) at which O is located is returned. In all other cases, it returns 0. In case the Sequence is not empty, an error is generated if I is not an Integer or if it is smaller than 1 or greater than the size of the Sequence</p><p><h4>iteratorAt(I:  Integer):  SequenceIterator</h4>Returns a (forward directed) Iterator to the element at index I of the Sequence if I is an Integer not smaller than 1 and not greater than the size of the Sequence. Otherwise, either an error is generated in case the Sequence is not empty or a finalized Iterator is returned  in case the Sequence is empty</p><p><h4>printString():  String</h4>Returns a pretty print</p></div><hr width="50%" align="left"><h2><a id="data-Queue"/>Queue (extends Collection)</h2>Queue (First-In-First-Out Ordering) of Unbounded or Finite Size - Creating a new Queue yields a Queue of unbounded size (capacity)<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>clear():  Queue</h4>Clears the contents of the Queue (by removing all elements)</p><p><h4>resize(S:  Integer):  Queue</h4>Modifies the size (capacity) of the Queue. If S is smaller than the current size (capacity), elements at the tail of the Queue are removed. If S equals nil then the size (capacity) is set to unbounded. If S is not nil or an Integer smaller than 1, an error is generated</p><p><h4>size():  Integer</h4>Returns the size (capacity) of the Queue or nil if unbounded</p><p><h4>occupation():  Integer</h4>Returns the number of elements in the Queue</p><p><h4>isEmpty():  Boolean</h4>Returns true in case the Queue does not contain any elements. Otherwise, it returns false</p><p><h4>isFull():  Boolean</h4>Returns true in case the size (capacity) of the Queue is bounded and equals its capacity. Otherwise, it returns false</p><p><h4>excludes(O:  Object):  Boolean</h4>Returns true in case there are no instances of O contained in the Queue. Otherwise, it returns false</p><p><h4>includes(O:  Object):  Boolean</h4>Returns true in case at least one instance of O is contained in the Queue. Otherwise, it returns false</p><p><h4>count(O:  Object):  Integer</h4>Returns the number of instances of O in the Queue</p><p><h4>add(O:  Object):  Queue</h4>Adds object O to the end (tail) of the Queue in case it is not full</p><p><h4>inspect():  Object</h4>Returns the first element (head) in the Queue if it is not empty. Otherwise, it returns nil. It does not modify the Queue</p><p><h4>remove():  Object</h4>Returns the first element (head) in the Queue and removes it from the Queue if not empty. Otherwise, it returns nil</p><p><h4>printString():  String</h4>Returns a pretty print</p></div><hr width="50%" align="left"><h2><a id="data-Stack"/>Stack (extends Collection)</h2>Stack (Last-In-First-Out Ordering) of Unbounded or Finite Size - Creating a new Stack yields a Stack of unbounded size (capacity)<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>clear():  Stack</h4>Clears the contents of the Stack (by removing all elements)</p><p><h4>resize(S:  Integer):  Stack</h4>Modifies the size (capacity) of the Stack. If S is smaller than the current size (capacity), elements at the tail of the Stack are removed. If S equals nil then the size (capacity) is set to unbounded. If S is not nil or an Integer smaller than 1, an error is generated</p><p><h4>size():  Integer</h4>Returns the size (capacity) of the Stack or nil if unbounded</p><p><h4>occupation():  Integer</h4>Returns the number of elements in the Stack</p><p><h4>isEmpty():  Boolean</h4>Returns true in case the Stack does not contain any elements. Otherwise, it returns false</p><p><h4>isFull():  Boolean</h4>Returns true in case the size (capacity) of the Stack is bounded and equals its capacity. Otherwise, it returns false</p><p><h4>excludes(O:  Object):  Boolean</h4>Returns true in case there are no instances of O contained in the Stack. Otherwise, it returns false</p><p><h4>includes(O:  Object):  Boolean</h4>Returns true in case at least one instance of O is contained in the Stack. Otherwise, it returns false</p><p><h4>count(O:  Object):  Integer</h4>Returns the number of instances of O in the Stack</p><p><h4>push(O:  Object):  Stack</h4>Adds object O to the end (tail) of the Stack in case it is not full</p><p><h4>inspect():  Object</h4>Returns the last element (tail) in the Stack if it is not empty. Otherwise, it returns nil. It does not modify the Stack</p><p><h4>pop():  Object</h4>Returns the last element (tail) in the Stack and removes it in case the Stack is not empty. Otherwise, it returns nil</p><p><h4>printString():  String</h4>Returns a pretty print</p></div><hr width="50%" align="left"><h2><a id="data-Set"/>Set (extends Collection)</h2>Set (Unordered Set) - Creating a new Set yields an empty Unordered Collection (Without Duplicate Instances)<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>=(S:  Object):  Boolean</h4>Returns true in case S is a Set and the receiver and S contain the same objects. Otherwise, false is returned</p><p><h4>!=(S:  Object):  Boolean</h4>Returns !(self = S)</p><p><h4>+(S:  Set):  Set</h4>Returns a new Set containing all elements of both the receiver and S (without duplicate instances). In case S is not a Set, an error is generated</p><p><h4>-(S:  Set):  Set</h4>Returns a new Set that contains only elements that are contained in the receiver but not in S (Set Difference). In case S is not a Set, an error is generated</p><p><h4>>(S:  Set):  Boolean</h4>Returns true in case the Set is a strict super set of S (i.e., the Set includes all elements of S and at least one other element). Otherwise, false is returned. In case S is not a Set, an error is generated</p><p><h4>>=(S:  Set):  Boolean</h4>Returns true in case the Set is a super set of S (i.e., the Set includes all elements of S). Otherwise, false is returned. In case S is not a Set, an error is generated</p><p><h4><(S:  Set):  Boolean</h4>Returns true in case the Set is a strict sub set of S. Otherwise, false is returned. In case S is not a Set, an error is generated</p><p><h4><=(S:  Set):  Boolean</h4>Returns true in case the Set is a sub set of S (i.e., S includes all elements of the Set and at least one other element). Otherwise, false is returned. In case S is not a Set, an error is generated</p><p><h4>iterator():  Iterator</h4>Returns an iterator for traversing the Set</p><p><h4>fromArray(A:  Array):  Set</h4>Modifies the Set by clearing its contents and subsequently adding all elements of Array A (without duplicate instances)</p><p><h4>count(O:  Object):  Integer</h4>Returns 1 in case O is included in the Set. Otherwise, 0 is returned</p><p><h4>add(O:  Object):  Set</h4>Adds O to the Set if it was not yet included. Otherwise, the Set remains unchanged</p><p><h4>remove(O:  Object):  Set</h4>Removes O from the Set if it was included. Otherwise, the Set remains unchanged</p><p><h4>union(S:  Set):  Set</h4>Modifies the Set by adding all elements of S to it (without duplicate instances). In case S is not a Set, an error is generated</p><p><h4>subtract(S:  Set):  Set</h4>Modifies the Set to no longer include the elements in S. In case S is not a Set, an error is generated</p><p><h4>difference(S:  Set):  Set</h4>Modifies the Set to become the symmetric difference of the Set and S. This means that those elements of the Set that are also in S are removed and those elements in S that are not in the Set are added. In case S is not a Set, an error is generated</p><p><h4>intersection(S:  Set):  Set</h4>Modifies the Set to contain only those elements that are contained in both the Set and S. In case S is not a Set, an error is generated</p><p><h4>printString():  String</h4>Returns a pretty print</p></div><hr width="50%" align="left"><h2><a id="data-Map"/>Map (extends Collection)</h2>Map (Key-Value Dictionary) - Creating a new Map yields an empty Key-Value Dictionary<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>=(M:  Object):  Boolean</h4>Returns true if M is a Map and the receiver and M contain the same key-value pairs. Otherwise, it returns false</p><p><h4>!=(M:  Object):  Boolean</h4>Returns !(self = M)</p><p><h4>clear():  Map</h4>Clears the contents of the Map (by removing all key-value pairs)</p><p><h4>isEmpty():  Boolean</h4>Returns true in case the Map does not contain any key-value pairs. Otherwise, it returns false</p><p><h4>size():  Integer</h4>Returns the number of key-value pairs in the Map</p><p><h4>iterator():  MapIterator</h4>Returns an iterator for traversing the Map</p><p><h4>includesKey(K:  Object):  Boolean</h4>Returns true in case key K is included in the Map. Otherwise, it returns false</p><p><h4>includesValue(V:  Object):  Boolean</h4>Returns true in case at least one instance of value V is included in the Map. Otherwise, it returns false</p><p><h4>keys():  Set</h4>Returns a Set with all keys in the Map</p><p><h4>values():  Bag</h4>Returns a Bag with all values corresponding to all keys (which may contain duplicate instances)</p><p><h4>putAt(Key:  Object, Value:  Object):  Map</h4>Modifies the Map to store value V at key K. In case key K was not yet included, it is added</p><p><h4>at(Key:  Object):  Object</h4>Returns the value at key K if such key is included in the Map. Otherwise, it returns nil</p><p><h4>removeAt(Key:  Object):  Map</h4>Modifies the Map by removing the key-value pair with key K (if it was included)</p><p><h4>printString():  String</h4>Returns a pretty print</p><p><h4>asJSON():  String</h4>Returns the receiver as a valid JSON (single line) string. It will throw an exception when it contains a non-serializable object.</p></div><hr width="50%" align="left"><h2><a id="data-Iterator"/>Iterator (extends Object)</h2>Iterator (Abstract super class used by MapIterator, BagIterator, SetIterator, SequenceIterator)<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>isDone():  Boolean</h4>Returns true in case all elements in the structure have been referred to. Otherwise, false is returned</p><p><h4>advance():  Iterator</h4>Modifies the Iterator to refer to the next element if there is still such element. Otherwise, the Iterator remains unchanged</p><p><h4>remove():  Iterator</h4>Modifies the underlying structure by removing the element to which the Iterator is pointing. The iterator advances to the next element in the underlying structure</p><p><h4>printString():  String</h4>Returns a pretty print</p><p><h4>key():  Object</h4>Returns the key (on map)</p><p><h4>value():  Object</h4>Returns the value</p><p><h4>element():  Object</h4>Returns the value</p></div><hr width="50%" align="left"><h2><a id="data-MapIterator"/>MapIterator (extends Iterator)</h2>MapIterator - Iterator for stepping through a map<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>key():  Object</h4>Returns the key of the key-value pair to which the iterator is pointing in the Map in case the Map is not empty. Otherwise, nil is returned</p><p><h4>isDone():  Boolean</h4>Returns true in case all elements in the structure have been referred to. Otherwise, false is returned</p><p><h4>value():  Object</h4>Returns the value of the key-value pair to which the iterator is pointing in the Map in case the Map is not empty. Otherwise, nil is returned</p><p><h4>remove():  Iterator</h4>Modifies the underlying structure by removing the element to which the Iterator is pointing. The iterator advances to the next element in the underlying structure</p><p><h4>advance():  Iterator</h4>Modifies the Iterator to refer to the next element if there is still such element. Otherwise, the Iterator remains unchanged</p></div><hr width="50%" align="left"><h2><a id="data-BagIterator"/>BagIterator (extends Iterator)</h2>BagIterator - Iterator for stepping through a bag<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>advance():  BagIterator</h4>Modifies the Iterator to refer to the next instance of the element in the Bag if there is still a next instance. Otherwise, the Iterator advances to the next element</p><p><h4>remove():  BagIterator</h4>Modifies the underlying Bag by removing one instance of the element to which the Iterator is pointing</p><p><h4>printString():  String</h4>Returns a pretty print</p><p><h4>count():  Object</h4>returns the count (number of times the object exists in the bag)</p></div><hr width="50%" align="left"><h2><a id="data-SetIterator"/>SetIterator (extends Iterator)</h2>SetIterator - Iterator for stepping through a set<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"></div><hr width="50%" align="left"><h2><a id="data-SequenceIterator"/>SequenceIterator (extends Iterator)</h2>SequenceIterator - Iterator for stepping through a sequence<h3>Variables:</h3><div class="indented"></div><h3>Methods:</h3><div class="indented"><p><h4>first():  SequenceIterator</h4>Modifies the Iterator to point to the first element in the Sequence</p><p><h4>last():  SequenceIterator</h4>Modifies the Iterator to point to the last element in the Sequence</p><p><h4>advance():  SequenceIterator</h4>Modifies the Iterator to refer to the next element (for forward directed iterators) or previous element (for reversely directed iterators) in the Sequence if there is still such element. Otherwise, the Iterator remains unchanged</p><p><h4>addBefore(O:  Object):  SequenceIterator</h4>Modifies the underlying sequence by inserting an element referring to the specified object. The element is inserted in the sequence before the currently referred element, not considering whether the direction of the iterator is reversed</p><p><h4>addAfter(O:  Object):  SequenceIterator</h4>Modifies the underlying sequence by inserting an element referring to the specified object. The element is inserted in the sequence after the currently referred element, not considering whether the direction of the iterator is reversed.
If isDone holds or the referred element is removed, an error is triggered. The iterator is not modified.</p></div><hr width="100%" align="left">
</body>
</html>